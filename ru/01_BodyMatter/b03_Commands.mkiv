%%% File:        b03_Commands.mkiv
%%% Author:      Joaquín Ataz-López
%%% Begun:       April 2020
%%% Concluded:   April 2020

% Contents:    Это центральная глава для понимания сути ConTeXt. Часть его содержимого основана на TeX. Использование зарезервированных символов и различие между управляющими символами и управляющими словами. Кнут настаивает на различии, но ни документация ConTeXt, ни документация LaTeX в целом этого не делают (несмотря на краткую ссылку в Kopka). Тем не менее, я считаю, что это различие важно для понимания того, почему в TeX имена команд не могут смешивать буквы и не буквы. Что касается объяснения команд, то есть решения по конструкциям «старт-стоп», которые я пока не решаюсь называть «средами». Но иногда они делают это и в вики. С другой стороны, я доволен своим объяснением \ setup + \ define на примере команды \ framed. Кроме других дополнительных концепций, я также хотел бы представить счетчики, но я не нашел никакой документации по названиям основных счетчиков в ConTeXt. Например, я провел различные тесты, манипулируя счетчиками глав вручную и .... пшик! Rien de rien. Ничего такого. Эта информация, имеющая центральное значение для управления ConTeXt, должна быть явно выражена где-нибудь.
%%% Edited with: Emacs + AuTeX - And at times with vim + context-plugin
%%%

\environment ../introCTX_env.mkiv

\startcomponent b03_Commands.mkiv

\startchapter
  [
    reference=cap:commands,
    title=Команды и другие базовые концепции\\ \ConTeXt,
    bookmark=Commands and other fundamental concepts of ConTeXt,
  ]

\TocChap

Мы уже видели, что в исходном файле, а также в фактическом содержании нашего будущего отформатированного документа мы находим инструкции, необходимые для объяснения \ConTeXt\ того, как мы хотим преобразовать нашу рукопись. Эти инструкции можно назвать «командами», «макросами» или «управляющими последовательностями».

\startSmallPrint

С точки зрения внутреннего функционирования \ConTeXt\ (фактически, функционирования \TeX), есть разница между {\em примитивами} и {\em макросами}. Примитив -- это простая инструкция, которую нельзя разбить на другие более простые инструкции. Макрос -- это инструкция, которая может быть разбита на другие более простые инструкции, которые, в свою очередь, также, возможно, могут быть разбиты на другие, и так далее и так далее. Фактически, большинство инструкций \ConTeXt\ являются макросами. С точки зрения программиста, разница между макросами и примитивами важна. Но с точки зрения пользователя проблема не так важна: в обоих случаях у нас есть инструкции, которые выполняются без необходимости беспокоиться о том, как они работают на низком уровне. Поэтому в документации \ConTeXt\ обычно говорится о {\em команде}, когда она учитывает точку зрения пользователя, и о {\em макросе}, когда она принимает точку зрения программиста. Поскольку во введении мы рассматриваем только точку зрения пользователя, я буду использовать любой термин, считая их синонимами.

{\em Команды} -- это приказы, отданные \ConTeXt\ что-либо сделать; через них мы контролируем работу программы. Таким образом, \cap{Knuth}, отец \TeX, использует термин {\em управляющие последовательности} для обозначения как примитивов, так и макросов, и я думаю, что это самый точный термин из всех. Я буду использовать его, когда считаю, что важно различать {\em управляющие символы} и {\em управляющие слова}.

\stopSmallPrint

Инструкции \ConTeXt\ в основном бывают двух видов: зарезервированные символы и собственно так называемые команды.

\startsection
  [
    reference=sec:reserved characters,
    title=Зарезервированные символы \ConTeXt,
  ]

Когда \ConTeXt\ читает исходный файл, состоящий только из текстовых символов, поскольку это текстовый файл, ему необходимо каким-то образом различать, какой текст на самом деле нужно форматировать, и какие инструкции он должен выполнять. Зарезервированные символы \ConTeXt\ позволяют ему делать это различие. В принципе, \ConTeXt\ предполагает, что каждый символ в исходном файле является текстом для обработки, если только это не один из 11 зарезервированных символов, которые следует рассматривать как {\em инструкцию}.

Всего 11 инструкций? Нет. Всего 11 зарезервированных символов; но поскольку один из них, символ \quotation{{\tt\backslash}}, имеет функцию преобразования символа или символов, непосредственно следующих за ним, в инструкцию, то на самом деле потенциальное количество команд не ограничено.  \ConTeXt\ имеет около 3000 команд (включая команды, эксклюзивные для Mark~II, Mark~IV, и те, которые являются общими для обеих версий).

Зарезервированные символы следующие:

{
  \switchtobodyfont[25pt]
  \midaligned{\cmd{ \% \{ \} \# \lettertilde\ \| \$ \_ \letterhat\ \&}}
}

\ConTeXt\ интерпретирует их следующим образом:

\semitable{\backslash}

Этот символ является для нас самым важным: он указывает на то, что то, что идет сразу после, следует интерпретировать не как текст, а как инструкцию. Он называется «escape-символом» или «escape-последовательностью» (хотя он не имеет ничего общего с клавишей «Esc», которая есть на большинстве клавиатур). \footnote{В компьютерной терминологии ключ, который влияет на интерпретацию следующего символа, называется escape-символом. В отличие от этого, клавиша escape на клавиатуре называется так, потому что она генерирует символ 27 в коде ASCII, который используется как escape-символ в этой кодировке. Сегодня использование клавиши Escape больше связано с идеей отмены текущего действия.}

\semitable{\%}

Сообщает \ConTeXt, что то, что следует до конца строки, является комментарием, который не должен обрабатываться или включаться в окончательный форматированный файл. Добавление комментариев в исходный файл чрезвычайно полезно. Комментарий может помочь объяснить, почему что-то было сделано определенным образом, и это очень полезно для завершенных исходных файлов, учитывая более позднюю редакцию, когда иногда мы не можем вспомнить, почему мы сделали то, что мы сделали; или это также может помочь нам в качестве напоминания о том, что нам, возможно, придется пересмотреть. Его даже можно использовать для определения причины определенной ошибки в исходном файле, поскольку, помещая метку комментария в начале строки, мы исключаем эту строку из компиляции и можем увидеть, была ли это та строка, которая вызвала ошибку; его также можно использовать для хранения двух разных версий одного и того же макроса и таким образом получить разные результаты после компиляции; или чтобы предотвратить компиляцию фрагмента, в котором мы не уверены, но не удаляя его из исходного файла на случай, если мы захотим вернуться к нему позже ... и т.д. Как только мы открыли возможность того, что наш исходный файл содержит текст, который никто, кроме нас самих, не должен видеть, наше использование этого символа ограничено только нашим собственным воображением. Признаюсь, это одна из тех утилит, которых мне больше всего не хватает, когда единственным средством для написания текста является текстовый процессор.

\semitable{\{}

Этот символ открывает группу. Группы - это блоки текста, на которые влияют определенные функции. О них мы поговорим в
 \in{section}[sec:groups].

\semitable{\}}

Этот символ закрывает группу, ранее открытую с помощью {\tt \{}.

\semitable{\#}

Этот символ используется для определения макросов. Это относится к аргументам макроса. См. \in{section}[sec:define] в этой главе.

\semitable{\lettertilde}

Вводит пробел в документ, чтобы предотвратить разрыв строки, что означает, что два слова, разделенные символом  \type{~}, всегда будут оставаться в одной строке. Об этой инструкции и о том, где её использовать, мы поговорим в  \in{section}[sec:lettertilde].

\semitable{\|}

Этот символ используется для обозначения того, что два слова, соединенные разделяющим элементом, составляют составное слово, которое можно разделить по слогам на первый компонент, но не на второй компонент. См. \in{section}[sec:compound words].

\semitable{\$}

Этот символ -- переключатель математического режима. Он включает этот режим, если он не был включен, или отключает его, если он был включен. В математическом режиме \ConTeXt\ применяет некоторые шрифты и правила, отличные от обычных, с целью оптимизации написания математических формул. Несмотря на то, что написание математики - очень важное применение \ConTeXt\, я не буду развивать это во введении. Как литератор, мне не до этого!

\semitable{\_}

Этот символ используется в математическом режиме для обозначения нижнего индекса. Так, например, чтобы получить$x_1$, нам нужно написать \type{$x_1$}.

\semitable{\letterhat}

Этот символ используется в математическом режиме для обозначения трех верхних индексов. Так, например, чтобы получить $(x+i)^{n^3}$ , нам нужно написать \type{$(x+i)^{n^3}$}.

\semitable{\&}

В документации \ConTeXt\ говорится, что это зарезервированный символ, но не объясняется, почему. В Plain \TeX\ этот символ в основном используется для двух целей: он используется для выравнивания столбцов в базовых средах таблиц и в математическом контексте, так что все последующее следует рассматривать как обычный текст. Во вводном руководстве \quotation{\ConTeXt\ Mark~IV, an Excursion}, хотя не говорится, для чего он предназначен, есть примеры его использования в математических формулах, хотя и не в том виде, в каком он был в Plain \TeX, но для выравнивания столбцов в \Doubt сложных функциях. Поскольку я литературный человек, я не чувствую, что могу проводить дальнейшие тесты, чтобы увидеть, для чего конкретно используется этот зарезервированный символ.

Можно предположить, что при выборе символов, которые будут зарезервированы, они будут символами, доступными на большинстве клавиатур, но обычно не используемыми в письменных сценариях. Однако, хотя это не так часто, всегда есть вероятность, что некоторые из них будут фигурировать в наших документах, например, когда мы хотим написать, что что-то стоит 100 долларов (\$100) или что в Испании процент водителей возраст старше 65 лет составлял 16\% в 2018 году. В этих случаях мы не должны писать зарезервированный символ напрямую, а использовать {\em команду}, которая будет правильно выводить зарезервированный символ в окончательный документ. Команда для каждого из зарезервированных символов находится в \in{table}[Reserved characters].

\placetable
  [here]
  [Reserved characters]
  {\tfx Написание зарезервированных символов}
{\starttabulate[|c|l|]
  \HL
  \NC {\bf Зарезервированные символы} \NC {\bf Команды, генерирующие их}\NR
  \HL
  \NC{\tt
    \backslash}\NC\PlaceMacro{backslash}\tex{backslash}\NR\macro{reserved characters+\backslash backslash}
  \NC{\tt \%}\NC{\cmd{\%}}\NR\macro{reserved characters+\backslash \%}
  \NC{\tt \{}\NC\cmd{\{}\NR\macro{reserved characters+\backslash \{}
  \NC{\tt \}}\NC\cmd{\}}\NR\macro{reserved characters+\backslash \}}
  \NC{\tt \#}\NC\cmd{\#}\NR\macro{reserved characters+\backslash \#}
  \NC{\tt \lettertilde}\NC\PlaceMacro{lettertilde}\tex{lettertilde}\NR\macro{reserved characters+\backslash lettertilde}
  \NC{\tt \|}\NC\cmd{\|}\NR\macro{reserved characters+\backslash \|}
  \NC{\tt \$}\NC\cmd{\$}\NR\macro{reserved characters+\backslash \$}
  \NC{\tt \_}\NC\cmd{\_}\NR\macro{reserved characters+\backslash \_}
  \NC{\tt \letterhat}\NC\PlaceMacro{letterhat}\tex{letterhat}\NR\macro{reserved characters+\backslash letterhat}
  \NC{\tt \&}\NC\cmd{\&}\macro{reserved characters+\backslash \&}\NR
  \HL
\stoptabulate}

Другой способ получить зарезервированные символы -- использовать команду \tex{type}. Эта команда отправляет то, что принимает в качестве аргумента, в окончательный документ без какой-либо обработки и, следовательно, без его интерпретации. В итоговом документе текст, полученный из \tex{type}, будет показан моноширинным шрифтом, типичным для компьютерных терминалов и пишущих машинок.

\startSmallPrint

Обычно мы заключаем текст, который должен отображать \tex{type}, в фигурные скобки. Однако, когда сам этот текст включает открывающие или закрывающие фигурные скобки, вместо них мы должны заключить текст между двумя равными символами, которые не являются частью текста, составляющего аргумент \tex{type}. Например: \cmd{type*\{*} или \cmd{type+\}+}.

\stopSmallPrint

Если по ошибке мы используем один из зарезервированных символов напрямую, кроме той цели, для которой он предназначен, потому что мы забыли, что это зарезервированный символ и не может использоваться как обычный, тогда могут произойти три вещи:

\startitemize[n]

  \item Чаще всего возникает ошибка при компиляции.

  \item Получаем неожиданный результат. Это особенно характерно для \MyKey{\lettertilde} и \MyKey{\%}; в первом случае вместо \MyKey{\lettertilde}, который мы ожидали в окончательном документе, будет вставлен пробел; и в последнем случае все в той же строке перестанет обрабатываться, начиная с \MyKey{\%}. Неправильное использование \quotation{{\tt\backslash}} также может привести к неожиданному результату, если он или символы сразу после него составляют команду, о которой \ConTeXt\ знает. Однако чаще всего, когда мы неправильно используем \quotation{{\tt\backslash}}, мы получаем ошибку компиляции.

  \item Проблем не возникает: это происходит с тремя зарезервированными символами, используемыми в основном в математике ({\tt _ ^ &}): если они используются вне этой среды, они рассматриваются как обычные символы.

  \startSmallPrint

Пункт 3 - это мой вывод. По правде говоря, я не нашел нигде в документации \ConTeXt, где говорилось бы, где эти зарезервированные символы могут использоваться \Conjecture{} напрямую; однако в своих тестах я не обнаружил никаких ошибок, когда это было сделано; в отличие, например, от \LaTeX.

  \stopSmallPrint

\stopitemize

\stopsection

\startsection
  [
    title=Сами команды,
    reference=sec:commands themselves,
  ]

Сами команды всегда начинаются с символа \quotation{{\tt\backslash}}. В зависимости от того, что идет сразу после escape-последовательности, различают:

\startitemize[a]

\item {\bf Управляющие символы.} Управляющий символ начинается с escape-последовательности (\quote{{\tt\backslash}}) и состоит исключительно из символа, отличного от буквы, например, \quote{\tex{,}}, \quotation{\tex{1}}, \quotation{\tex{'}} или \quotation{\type{\%}}. Любой символ или символ, не являющийся буквой в строгом смысле этого слова, может быть контрольным символом, включая числа, знаки препинания, символы и даже пробел. В этом документе, чтобы представить пустое пространство (пробел), когда его присутствие необходимо выделить, я использую символ \textvisiblespace. Фактически, \quotation{\cmd{\textvisiblespace}} (обратная косая черта, за которой следует пробел) является обычно используемым управляющим символом, как мы скоро увидим.

  \startSmallPrint\reference[note:invisible space]{}

Пробел или пробел -- это символ \quote{невидимый}, что является проблемой в таком документе, где иногда нам нужно четко указать, что нужно записать в исходный файл. {\sc Knuth} уже знал об этой проблеме, и в своей \quote{The \TeX Book} он начал обычай представлять значимые пробелы с помощью символа \quotation{\textvisiblespace}. Так, например, если мы хотим показать, что два слова в исходном файле должны быть разделены двумя пробелами, мы должны написать \quote{word1\textvisiblespace\textvisiblespace word2}.

  \stopSmallPrint

\item {\bf Управляющие слова.} Если символ, следующий за обратной косой чертой, является буквой в собственном смысле слова, команда будет {\em Управляющим словом}. Эта группа команд является самой многочисленной и её особенностью является то, что имя команды может состоять только из букв; цифры, знаки препинания или любые другие символы не допускаются. Только строчные или прописные буквы. С другой стороны, помните, что \ConTeXt\ делает различие между нижним и верхним регистрами, а это означает, что команды \tex{mycommand} и \tex{MyCommand} различны. Но \tex{MyCommand1} и \tex{MyCommand2} будут считаться одинаковыми, поскольку \quote{1} и \quote{2} не являются буквами, а значит не являются частью имен команд.

  \startSmallPrint

Справочное руководство \ConTeXt\ не содержит правил для имён команд, как и остальные \quotation{manuals}, включенные в \Conjecture \suite-. В предыдущем абзаце я сделал вывод, основанный на том, что происходит в \TeX\ (где, кроме того, такие символы, как гласные с ударением, которые не встречаются в английском алфавите, не считаются \quotation{буквами}). Это правило позволяет предложить хорошее объяснение поглощения пробелов после имени команды.

  \stopSmallPrint

\stopitemize

Когда \ConTeXt\ читает исходный файл и находит escape-символ (\quotation{{\tt\backslash}}), он знает, что за ним последует команда. Затем он считывает первый символ, следующий за escape-последовательностью. Если это не буква, это означает, что команда является управляющим символом и состоит только из этого первого символа. Но с другой стороны, если первый символ после escape-последовательности -- это буква, то \ConTeXt\ будет продолжать читать каждый символ, пока не найдет первую не букву, а затем он узнает, что имя команды закончилось. Вот почему имена команд, которые являются управляющими словами, не могут содержать символы, не являющиеся буквами.

Когда \quotation{non-letter} в конце имени команды является пробелом, предполагается, что пробел не является частью обрабатываемого текста, а был вставлен исключительно для указания того, где заканчивается имя команды, тогда \ConTeXt\ избавляется от этого пространства. Это производит эффект, который удивляет новичков в \ConTeXt, потому что когда эффект рассматриваемой команды подразумевает запись чего-либо в окончательном документе, письменный вывод команды соединяется со следующим словом. Например, следующие два предложения в исходном файле

{\switchtobodyfont[small]
\starttyping
Знание \TeX помогает в изучении \ConTeXt.
Знание \TeX, хотя и не обязательно, помогает в изучении \ConTeXt
\stoptyping
}

соответственно дают следующие результаты:

{
\tfx\color[red]{Знание \TeX помогает в изучении \ConTeXt.\\%
Знание \TeX, хотя и не обязательно, помогает в изучении \ConTeXt.%
}\footnote{{\bf Примечание:} два соглашения соблюдаются в тех случаях, когда, чтобы проиллюстрировать что-то в этом введении, написан фрагмент исходного кода, а также результат его компиляции: иногда код и результат его компиляции размещаются рядом друг с другом в абзаце из двух столбцов; в других случаях код написан в \color[purple]{темно-пурпурном оттенке}, который обычно используется в этом документ для представления команд \ConTeXt\, а результат его компиляции - красным цветом.}}

Обратите внимание, как в первом случае слово \quotation{\TeX} связано со следующим за ним словом, но не во втором случае. Это связано с тем, что в первом случае в исходном файле первая \quotation{non-letter} после имени команды \tex{TeX} была пустым пространством, подавленным, поскольку \ConTeXt\ предполагал, что он был там только для обозначения конца имени команды, в то время как в во втором экземпляре была запятая, и поскольку это не пробел, он не был подавлен.

С другой стороны, эта проблема не решается простым добавлением лишнего пробела и написанием, например,

\color[darkmagenta]{{\tt Знание \backslash TeX\textvisiblespace\textvisiblespace
помогает в изучении \backslash ConTeXt}}\footnote{Что касается символа \quotation{\textvisiblespace},
вспомните примечание на \at{page}[note:invisible space].}.

не решит проблему, потому что правило \ConTeXt\ (которое мы увидим в \in{section}[sec:spaces]) заключается в том, что пустое пространство поглощает все пробелы и табуляции, которые следуют за ним. Поэтому, когда у нас возникает эта проблема (которая, к счастью, случается не слишком часто), мы должны убедиться, что первое «небуквенное» имя после имени команды не является пробелом. На это есть два кандидата:

\startitemize[1]

\item Зарезервированные символы \MyKey{\{\}}. Зарезервированный символ \MyKey{\{}, как я уже сказал, открывает группу, а \MyKey{\}} закрывает группу, поэтому последовательность \MyKey{\{\}} вводит пустую группу. Пустая группа не влияет на окончательный документ, но помогает \ConTeXt\ узнать, имя команды до её завершения. Или мы могли бы также создать группу вокруг рассматриваемой команды, например, написав \quotation{\{\tex{TeX}\}}. В любом случае результатом будет то, что первое \quote{non-letter} после \tex{TeX} не будет пробелом.

 \item Контрольный символ \quotation{\cmd{\textvisiblespace}} (обратная косая черта, за которой следует пробел, см. \at{page}[note:invisible space]). Эффект этого управляющего символа заключается во вставке пустого места в окончательный документ. Чтобы правильно понять логику \ConTeXt, возможно, стоит потратить некоторое время, чтобы посмотреть, что происходит, когда \ConTeXt\ встречает управляющее слово (например, \tex{TeX}), за которым следует управляющий символ (например, \quotation{\cmd{\textvisiblespace}}):

   \startitemize[2, packed]

    \item \ConTeXt\ встречает символ \backslash\, за которым следует \quote{T}, и зная, что он стоит перед контрольным словом, он продолжает читать символы, пока не дойдет до «небуквенного», что происходит, когда доходит до символа \backslash\, представляющего следующий символ управления.


    \item Как только он узнает, что имя команды \tex{TeX}, он запускает команду и печатает \TeX\ в окончательном документе. Затем он возвращается к точке, в которой он остановил чтение, чтобы проверить символ сразу после второй обратной косой черты.

    \item Он проверяет, является ли это пустым пространством, что означает «не буква», что означает, что последовательность управления именно такая, поэтому он может её запустить. Он делает это и вставляет пустое место.

    \item Наконец, он снова возвращается к точке, в которой он прекратил чтение (пустое пространство, которое было символом управления), и продолжает обрабатывать исходный файл оттуда и далее.

  \stopitemize

\stopitemize

Я объяснил этот механизм довольно подробно, так как устранение пробелов часто удивляет новичков. Однако следует отметить, что проблема относительно незначительна, поскольку контрольные слова обычно не печатаются непосредственно в окончательном документе, но влияют на формат и внешний вид. Напротив, контрольные символы довольно часто печатают что-то в окончательном документе.

\startSmallPrint

  Существует третья процедура, позволяющая избежать проблемы с пустым пространством, которая состоит в определении (стиль \TeX\) аналогичной команды и включении «небуквенного» в конце имени команды. Например, такая последовательность:

   \type{\def\txt-{\TeX}}

создаст команду с именем \tex{txt}, которая будет действовать точно так же, как команда  \tex{TeX}, и будет работать правильно только в том случае, если вызывается с дефисом после нее \tex{txt-}. Этот дефис технически не является частью имени команды, но он не будет работать, если за именем не будет стоять дефис. Почему это так, связано с механизмом определения макросов \TeX, и это слишком сложно объяснять здесь. Но это работает: как только эта команда определена, каждый раз, когда мы используем \tex{txt-}, \ConTeXt\ заменяет её на \tex{TeX}, удаляя дефис, но используя его внутренне, чтобы знать, что имя команды уже закончено, поэтому сразу после него появляется пустое пространство, которое не будет удалено.

Этот «трюк» не будет корректно работать с командой \tex{define}, которая является специальной командой \ConTeXt\ для определения макросов.

\stopSmallPrint

\stopsection

\startsection
  [title=Область действия команд]

\startsubsection
  [
    reference=sec:command scope,
    title={Команды, которые требуют или не требуют указания области действия}
  ]

Многие из команд \ConTeXt, особенно те, которые влияют на функции форматирования шрифтов (полужирный, курсив, маленькие заглавные буквы и т.д.), включают определенную функцию, которая остается включенной до тех пор, пока не встретится другая команда, которая отключает её или включает другую функцию, несовместимую с ней. Например, команда \tex{bf} включает полужирный шрифт, и он будет оставаться активным до тех пор, пока не найдет {\em несовместимую} команду, например, \tex{tf} или \tex{it}.

Команды такого типа не должны принимать никаких аргументов, поскольку они не предназначены для применения только к определенному тексту. Как будто они ограничены {\em включением} любой функции (полужирный, курсив, без засечек, определенный размер шрифта и т.д.).

Когда эти команды выполняются в {\em группе} (см. \in{section}[sec:groups]), они также теряют свою действенность, когда группа, в которой они выполняются, закрывается. Поэтому часто для того, чтобы эти команды влияли только на часть текста, нужно сгенерировать группу, содержащую эту команду и текст, на который мы хотим, чтобы она повлияла. Группа создается заключением её в фигурные скобки. Поэтому следующий текст

\startDoubleExample

\starttyping
In {\it The \TeX Book}, {\sc Knuth}
explained everything you need to know
about \TeX.
\stoptyping

In {\it The \TeX Book}, {\sc Knuth} explained everything you need to know
about \TeX.

\stopDoubleExample

создает две группы: одну для определения области действия команды \tex{it} (курсив), а другую - для определения области действия команды \tex{sc} (маленькие заглавные буквы).

В отличие от этого вида команд, есть другие, которые из-за производимого ими эффекта или по другим причинам требуют чёткого указания того, к какому тексту они должны применяться. В этих случаях текст, на который будет воздействовать команда, заключен в фигурные скобки {\em сразу после команды}. В качестве примера мы могли бы упомянуть \tex{framed}: эта команда рисует рамку вокруг текста, который принимает в качестве аргумента, так что

{\tfx\type{\framed{Tweedledum and Tweedledee}}}

будет производить\blank

\example{\framed{Tweedledum and Tweedledee}}

Обратите внимание, что хотя в первой группе команд (тех, которые требуют аргумента) фигурные скобки также иногда используются для определения поля действия, это не обязательно для работы команды. Команда предназначена для применения с того места, где она появляется. Таким образом, при определении области применения с помощью скобок команда помещается {\em внутрь этих скобок}, в отличие от второй группы команд, где скобки, обрамляющие текст, к которому должна применяться команда, идут {\em после} команды.

В случае команды \tex{framed} очевидно, что для создаваемого ею эффекта требуется аргумент -- текст, к которому она должна применяться. В других случаях от программиста зависит, относится ли команда к тому или иному типу. Так, например, то, что делают команды \tex{it} и \tex{color}, очень похоже: они применяют функцию (формат или цвет) к тексту. Но было принято решение запрограммировать первую без аргумента, а вторую как команду с аргументом.

\stopsubsection

\startsubsection
  [title={Команды, требующие явного указания того, где они начинаются и заканчиваются (среды)}]

Существуют определенные команды, которые определяют их область действия, точно указывая точку, в которой они начинают применяться, и точку, в которой они перестают это делать. Таким образом, эти команды бывают парами: одна указывает, когда команда должна быть активирована, а другая -- когда это действие должно быть прекращено. \quotation{start}, за которым следует имя команды, используется для обозначения начала действия, а \quotation{stop}, за которым также следует имя команды, для обозначения конца. Так, например, команда \MyKey{itemize} становится \tex{startitemize}, чтобы указать начало {\em итемизации}, и \tex{\stopitemize}, чтобы указать, где она заканчивается.

В официальной документации \ConTeXt\ нет специального названия для этих пар команд. Справочное руководство и введение просто называют их «старт ... стоп». Иногда их называют {\em средами}, это название \LaTeX\ дает аналогичным конструкциям, хотя у этого есть недостаток, заключающийся в том, что в \ConTeXt\ термин «среда» используется для чего-то ещё (особого типа файла, который мы увидим, когда будем говорить про многофайловые проекты в \in{section}[sec-projects]). Тем не менее, поскольку термин «среда» ясен, а контекст позволит легко различить, говорим ли мы о {\em командах среды} или {\em файлах среды}, я буду использовать этот термин.

Таким образом, среды состоят из команды, которая их открывает или запускает, и другой, которая закрывает или завершает их. Если исходный файл содержит команду на открытие среды, которая не закрывается позже, обычно возникает ошибка. \footnote{Хотя не всегда; это зависит от рассматриваемой среды и от ситуации в остальной части документа. В этом отношении \ConTeXt\ отличается от \LaTeX, который намного строже.} С другой стороны, такие ошибки труднее найти, поскольку ошибка может возникнуть далеко за пределами того места, где происходит команда открытия. Иногда файл \MyKey{.log} покажет нам строку, с которой начинается неправильно закрытая среда; но в других случаях отсутствие закрытия среды означает, что \ConTeXt\ неверно интерпретирует определенный отрывок, а не в этой ошибочной среде, а это означает, что файл \MyKey{.log} не очень помогает нам в поиске проблемы.

Среды могут быть вложенными, то есть другая среда может быть открыта в существующей среде, хотя в случае наличия вложенных сред каждую среду необходимо закрыть внутри той среды, в которой она была открыта. Другими словами, порядок, в котором закрываются среды, должен соответствовать порядку, в котором они были открыты. Я считаю, что это должно быть ясно из следующего примера:

{\switchtobodyfont[small]
\startframedtext
\starttyping
\startSomething
  ...
  \startSomethingElse
    ...
    \startAnotherSomethingElse
      ...
    \stopAnotherSomethingElse
  \stopSomethingElse
\stopSomething
\stoptyping
\stopframedtext
}

В этом примере вы можете увидеть, как среда \MyKey{AnotherSomethingElse} была открыта внутри среды \MyKey{SomethingElse} и также должна быть закрыта внутри неё. В противном случае при компиляции файла возникнет ошибка.

В общем, команды, разработанные как {\em среды}, реализуют некоторые изменения, предназначенные для применения к блокам текста размером не меньше абзаца. Например, \MyKey{более узкая} среда, изменяющая поля, имеет смысл только при применении на уровне абзаца; или среда \MyKey{framedtext}, которая обрамляет один или несколько абзацев. Эта последняя среда может помочь нам понять, почему некоторые команды разработаны как среды, а другие - как отдельные команды: если мы хотим поместить одно или несколько слов в одну строку, мы должны использовать команду \tex{framed}, но если то, что мы хотим, обрамить - это целый абзац (или несколько абзацев), тогда мы будем использовать среду \MyKey{framedtext}.

С другой стороны, текст, расположенный в определенной среде, обычно составляет {\em группу} (см. \in{section}[sec:groups]), что означает, что, если внутри среды обнаружена команда активации, из тех команд, которые применяются ко всему последующему тексту, эта команда будет применяться только до конца среды, в которой он находится; и на самом деле \ConTeXt\ имеет безымянную {\em среду}, начинающуюся с команды \tex{start} (никакой другой текст не следует; просто {\em start}. Вот почему я называю её {\em безымянной средой}) и заканчивающуюся командой \tex{stop}. Я подозреваю, что единственная её функция -- создание группы.

\startSmallPrint

Я нигде в документации \Conjecture\ConTeXt\ не читал, что одним из эффектов сред является группировка их содержимого, но это результат моих тестов с рядом предопределенных сред, хотя я должен признать, что мои тесты не были слишком исчерпывающими. Я просто проверил несколько случайно выбранных сред. Мои тесты показывают, однако, что такое утверждение, если оно истинно, будет справедливым только для некоторых предопределенных сред: те, которые созданы с помощью команды \tex{definestartstop} (объяснено в \in{section}[sec:startstop]), не создают никакой группы, если только при определении новой среды мы не включим команды, необходимые для создания группы (см. \in{section}[sec:groups]).

Я также предполагаю, что среда, которую я назвал средой {\em unnamed} (\tex{start}), предназначена только для создания группы: она создает группу, но имеет ли она какое-либо другое применение, я не знаю. Это одна из недокументированных команд в справочном руководстве.

\stopSmallPrint

\stopsubsection

\stopsection

\startsection
  [
    title=Опции командных операций,
    reference=sec:command options,
  ]

\startsubsection
  [title={Команды, которые могут работать по-разному}]

Многие команды могут работать более чем одним способом. В таких случаях всегда существует предопределенный способ работы, который можно изменить, указав параметры, соответствующие желаемой операции, в скобках после имени команды.

Мы находим хороший пример того, что я только что сказал, с помощью команды \tex{\framed}, упомянутой в предыдущем разделе. Эта команда рисует рамку вокруг текста, который принимает в качестве аргумента. По умолчанию рамка имеет высоту и ширину текста, к которому она применяется; но мы можем указать другую высоту и ширину. Таким образом, мы можем видеть разницу между тем, как работает \tex{\framed} по умолчанию:

\startDoubleExample

  \type{\framed{Tweedledum}}

  \framed{Tweedledum}

\stopDoubleExample

и как работает настроенная версия:

\startDoubleExample

\starttyping
\framed
  [width=3cm, height=1cm]
  {Tweedledum}
\stoptyping

\framed
  [width=3cm, height=1cm]
  {Tweedledum}

\stopDoubleExample

Во втором примере между квадратными скобками мы указали конкретную ширину и высоту фрейма, который окружает текст, который он принимает в качестве аргумента. В скобках различные параметры конфигурации разделяются запятой; пробелы и даже разрывы строк (если они не являются двойным разрывом строки) между двумя или более параметрами не принимаются во внимание, поэтому, например, следующие четыре версии одной и той же команды дают точно такой же результат:

{\switchtobodyfont[small]
\startframedtext
\starttyping
\framed[width=3cm,height=1cm]{Tweedledum}

\framed[width=3cm,    height=1cm]{Tweedledum}

\framed
  [width=3cm, height=1cm]
  {Tweedledum}

\framed
  [width=3cm,
    height=1cm]
  {Tweedledum}

\stoptyping
\stopframedtext
}

Очевидно, что финальная версия наиболее удобна для чтения: мы с первого взгляда можем увидеть, сколько существует опций и как они используются. В примере, подобном этому, только с двумя вариантами, возможно, это может показаться не таким важным; но в случаях, когда есть длинный список опций, если каждая из них имеет свою собственную строку в исходном файле, это упрощает {\em понимание} того, что исходный файл просит \ConTeXt\ сделать, а также, при необходимости, обнаружить потенциальную ошибка. Следовательно, этот последний формат (или аналогичный) для написания команд является «предпочтительным» для пользователей.

Что касается синтаксиса параметров конфигурации, см.
(\in{section}[sec:syntax]).

\stopsubsection

\startsubsection
  [title={Команды, которые настраивают, как другие\\ команды работают (\cmd{setupSomething})}]

Мы уже видели, что команды, которые поддерживают различные возможности того, как они работают, всегда имеют способ работы по умолчанию. Если одна из этих команд вызывается несколько раз в нашем исходном файле, и мы хотели бы изменить значение по умолчанию для них всех, вместо того, чтобы изменять эти параметры каждый раз при вызове команды, гораздо удобнее и эффективнее изменить значение по умолчанию. Для этого почти всегда доступна команда, имя которой начинается с \tex{\setup}, за которым следует имя команды, параметры которой по умолчанию мы хотим изменить.

Команда \tex{\framed}, которую мы использовали в качестве примера в этом разделе, продолжает оставаться хорошим образцом. Итак, если мы используем много фреймов в нашем документе, но все они нуждаются в точных измерениях, тогда было бы лучше перенастроить, как работает \tex{\framed}, сделав это с помощью \tex{\setupframed}. Таким образом

{\switchtobodyfont[small]
\starttyping
\setupframed
  [
    width=3cm,
    height=1cm
  ]
\stoptyping
}

будет обеспечено, что с этого момента каждый раз, когда мы вызываем \tex{\framed}, по умолчанию он будет генерировать рамку шириной 3 см и высотой 1 см, без необходимости указывать это каждый раз явно.

В \ConTeXt\ около 300 команд, которые позволяют нам настраивать работу других команд. Таким образом, мы можем настроить работу по умолчанию фреймов \tex{(\framed)}, списков (\MyKey{itemize}), заголовков глав \tex{(\chapter)} или заголовков разделов \tex{(\section)} и т.д.

\stopsubsection

\startsubsection
  [title=Настройка индивидуальных версий настраиваемых команд (\cmd{defineSomething})]

Продолжая пример \tex{framed}, очевидно, что если в нашем документе используются несколько видов фреймов, каждый с разными размерами, идеальным было бы то, что мы могли бы заранее {\em предопределить} различные конфигурации \tex{framed} и связать их с определенным именем, чтобы мы могли использовать тот или иной из них по мере необходимости. Мы можем сделать это в \ConTeXt\ с помощью команды \tex{defineframed}, синтаксис которой:

\type{\defineframed[Name][Configuration]}

где {\em Name} -- это имя, присвоенное конкретному типу настраиваемого фрейма; и {\em Configuration} -- это конкретная {\em Конфигурация}, связанная с этим именем.

Результатом всего этого будет то, что указанная конфигурация будет связана с установленным нами именем, которое, по сути, будет работать так, как если бы это была новая команда, и мы можем использовать это в любом контексте, где мы могли бы использовать исходную команду \tex{(\framed)}.

Эта возможность существует не только для конкретного случая команды \tex{framed}, но и для многих команд, у которых есть возможность \tex{setup}. Комбинация \tex{defineSomething} + \tex{setupSomething} -- это механизм, который придает \ConTeXt\ исключительную мощь и гибкость. Если мы подробно рассмотрим, что делает команда \tex{defineSomething}, мы увидим, что:

\startitemize[packed]

  \item Прежде всего, он клонирует определенную команду, которая поддерживает множество конфигураций.

  \item Он связывает этот клон с именем новой команды.

  \item Наконец, он устанавливает предопределенную конфигурацию для клона, отличную от того, как была настроена исходная команда.

\stopitemize

В приведенном нами примере мы настраивали специальный фрейм одновременно с его созданием. Но мы также можем сначала создать его, а потом настроить, потому что, как я уже сказал, после создания клона его можно использовать там, где можно было бы использовать оригинал. Так, например, если мы создали фрейм под названием \MyKey{MySpecialFrame}, мы можем настроить его с помощью \tex{setupframed}, указывающего фактический фрейм, который мы хотим настроить. В этом случае команда \tex{setup} примет новый аргумент с именем настраиваемого фрейма:

{\switchtobodyfont[small]
\vbox{\starttyping
\defineframed[MySpecialFrame]

\setupframed
  [MySpecialFrame]
  [ ... ]
\stoptyping
}}

\stopsubsection

\stopsection

\startsection
  [
    reference=sec:syntax,
    title={Краткое описание синтаксиса команд и параметров, а также использования квадратных и фигурных скобок при их вызове},
  ]
  % этот раздел специально посвящен пользователям LaTeX, чтобы они могли понять различное использование таких скобок.

Подводя итог тому, что мы видели до сих пор, мы видим, что в \ConTeXt\

\startitemize

  \item Собственно так называемые команды всегда начинаются с символа \quotation{{\tt\backslash}}.

  \item Некоторые команды могут принимать один или несколько аргументов.

  \item Аргументы, которые сообщают команде, {\em как} она должна работать или которые каким-то образом влияют на её работу, вводятся в квадратных скобках.

   \item Аргументы, которые сообщают команде, с какой частью текста она должна действовать, помещаются в фигурные скобки.

  \startSmallPrint

Когда команда будет действовать только с одной буквой, как, например, в случае с командой \tex{buildtextcedilla} (просто для примера - \quote{ç}, так часто используемая в каталонском языке), фигурные скобки вокруг аргумента можно опустить: команда будет применена к первому символу, не являющемуся пробелом.

  \stopSmallPrint

  \item Некоторые аргументы могут быть необязательными, и в этом случае мы можем их опустить. Но мы никогда не сможем изменить порядок аргументов, ожидаемых командой.

\stopitemize

Аргументы, заключенные в квадратные скобки, могут быть разных типов. В основном:

\startitemize

  \item Они могут принимать только одно значение, которое почти всегда будет одним словом или фразой.

  \item Они могут выбрать различные варианты, и в этом случае они могут:

  \startitemize

    \item Быть представленным одним словом, которое может быть символическим именем (значение которого \ConTeXt\ знает), мерой или измерением, числом, именем другой команды и т.д.

    \item Состоят из имен переменных, которым необходимо присвоить значение. В этом случае официальное определение команды (см. \in{section}[sec:qrc-setup-en]) всегда сообщает нам, какое значение ожидает каждая из опций.

    \startitemize

      \item Если значение, ожидаемое параметром, является текстом, оно может содержать пробелы, а также команды. В этих случаях иногда удобно заключить значение параметра в фигурные скобки.

      \item Когда значение, ожидаемое параметром, является командой, обычно мы можем указать несколько команд в качестве значения параметра, хотя иногда нам нужно заключить все команды, назначенные параметру, в фигурные скобки. Мы также должны заключить содержимое параметра в фигурные скобки, если какая-либо из включенных в него команд принимает параметр в квадратные скобки.

    \stopitemize

  \stopitemize

 В обоих случаях разные параметры, которые должны принимать один и тот же аргумент, будут разделены запятыми. Пробелы и разрывы строк (кроме двойных) между различными параметрами игнорируются. Пробелы и разрывы строк между различными аргументами команды также игнорируются.

  \item Наконец, в случае \ConTeXt\ никогда не бывает, чтобы один и тот же аргумент одновременно принимал параметры, состоящие из слова, и параметры, состоящие из переменной, которой должно быть явно присвоено значение. Другими словами, у нас могут быть такие варианты, как

  \type{\command[Option1, Option2, ...]}

 и другие как

  \type{\command[Variable1=value, Variable2=value, ...]}

  Но мы никогда не сможем найти сочетание того и другого:

  \type{\command[Option1, Variable1=value, ...]}

\stopitemize

\stopsection

\startsection
  [
    title={Официальный список команд \\ \ConTeXt},
    reference={sec:qrc-setup-en}
  ]
  % Этот раздел написан только для того, чтобы иметь возможность ссылаться на него каждый раз, когда упоминается "официальный список" команд.

Среди документации \ConTeXt\ есть особенно важный документ со списком всех команд, указывающим для каждой из них, сколько аргументов они ожидают и какого типа, а также различные предусмотренные параметры и их допустимые значения. Этот документ называется \MyKey{setup|-|en.pdf} и создается автоматически для каждой новой версии \ConTeXt. Его можно найти в каталоге под названием \MyKey{tex/texmf|-|context/doc/context/documents/general/qrcs}.

\startSmallPrint

Фактически, \MyKey{qrc} имеет семь версий этого документа, по одной для каждого из языков, имеющих интерфейс \ConTeXt: немецкого, чешского, французского, голландского, английского, итальянского и румынского. Для каждого из этих языков в каталоге есть два документа: один с названием \MyKey{setup-LangCode} (где LangCode - это буквенный код идентификации двух международных языков) и второй документ с именем \MyKey{setup-mapping-LangCode}. Этот второй документ содержит список команд в алфавитном порядке и указывает {\em прототип} команды, но без дополнительной информации о вероятных значениях для каждого аргумента.

\stopSmallPrint

Этот документ является фундаментальным для обучения использованию \ConTeXt, потому что именно там мы можем узнать, существует ли определенная команда; это особенно полезно, учитывая {\sc command} (or {\sc environment}) + {setup{\sc command} + define{\sc command}. Например, если я знаю, что с помощью команды \tex{blank} вводится пустая строка, я могу узнать, есть ли команда с именем \tex{setupblank}, которая позволяет мне её настроить, и другая, которая позволяет мне настраивать индивидуальную конфигурацию для пустых строк,  (\tex{defineblank}).

\startSmallPrint

 \MyKey{setup-en.pdf}, таким образом, является основополагающим для изучения \ConTeXt. Но я бы действительно предпочел, прежде всего, чтобы он сообщал нам, работает ли команда только в Mark~II или Mark~IV, и особенно, что если бы вместо того, чтобы сообщать нам только количество типов аргументов, которые позволяет каждая команда, она бы расскажите нам, для чего нужны эти аргументы. Это значительно уменьшило бы недостатки документации \ConTeXt. Есть некоторые команды, которые допускают необязательные аргументы, которые я даже не упоминаю в этом введении, потому что я не знаю, для чего они нужны, и, поскольку они являются необязательными, нет необходимости их упоминать. Это очень расстраивает.

\stopSmallPrint

\stopsection

\startsection
  [
    reference=sec:definingcommands,
    title=Определение новых команд,
  ]

\startsubsection
  [
    reference=sec:define,
    title=Общий механизм определения\\ новых команд,
  ]
\PlaceMacro{define}

Мы только что увидели, как с помощью \tex{defineSomething} мы можем клонировать уже существующую команду и разработать на её основе новую версию, которая будет работать во всех смыслах и целях как новая команда.

Наряду с этой возможностью, которая доступна только некоторым конкретным командам (определенно немало, но не всем), \ConTeXt\ имеет общий механизм для определения новых команд, который является чрезвычайно мощным, хотя в некоторых случаях его использование также довольно сложно. В подобном тексте, предназначенном для начинающих, я считаю, что лучше всего представить его, начав с некоторых из его простейших применений. Самый простой из всех -- связать фрагменты текста со словом, чтобы каждый раз, когда это слово появляется в исходном файле, оно заменяется связанным с ним текстом. Это позволит нам, с одной стороны, сэкономить много времени на набор текста, а с другой стороны, в качестве дополнительного преимущества, это снижает вероятность ошибок при наборе текста, гарантируя, что рассматриваемый текст всегда записывается так же.

Представим, например, что мы пишем трактат об аллитерации в латинских текстах, где мы часто цитируем латинское предложение «O Tite tute Tati tibi tanta tyranne tulisti» (О Тит Татий, ты тиран, столько ты принес на себя!). Это довольно длинное предложение, в котором два слова являются именами собственными и начинаются с заглавных букв, и где, давайте признаем это, как бы мы ни любили латинскую поэзию, нам легко «споткнуться» при её написании. В этом случае мы могли бы просто вставить преамбулу нашего исходного файла:

{\tfx \type{\define\Tite{\quotation{O Tite tute Tati tibi tanta tyranne tulisti}}}}

Основываясь на таком определении, каждый раз, когда команда \tex{Tite} появляется в нашем исходном файле, она будет заменена указанным предложением, и она также будет заключена в кавычки, как и в исходном определении, что позволяет нам гарантировать, что то, как это предложение появляется, всегда будет одним и тем же. Мы могли бы также написать его курсивом, с большим размером шрифта ... как нам угодно. Важно то, что нам нужно написать его только один раз, и по всему тексту он будет воспроизводиться именно так, как был написан, столько раз, сколько мы захотим. Мы также могли бы создать две версии команды, называемые \tex{Tite} и \tex{tite}, в зависимости от того, нужно ли писать предложение заглавными буквами или нет. Текст замены может быть чистым текстом или включать команды, или формировать математические выражения, в которых больше шансов опечатки (по крайней мере, для меня). Например, если выражение $(x_1,\ldots,x_n)$ должно регулярно появляться в нашем тексте, мы могли бы создать команду для его представления. Например

{\tfx\type{\define\xvec{$(x_1,\ldots,x_n)$}}}

так что всякий раз, когда \tex{xvec} появляется в тексте, он заменяется связанным с ним выражением.

Общий синтаксис команды  \tex{define} следующий:

\type{\define[NumArguments]\CommandName{TeXtToReplace}}

% {\ttx \color[maincolor]{\backslash define[{\em
%         NumArguments}]\backslash {\em CommandName}\{{\em
%       TextoReplace}\}}}

где

\startitemize[packed]

  \item {\tt\bf NumArguments} указывает количество аргументов, которые примет новая команда. Если в этом нет необходимости, как в приведенных выше примерах, это будет опущено.

  \item {\tt\bf CommandName} относится к имени, которое будет иметь новая команда. Здесь применяются общие правила, касающиеся имен команд. Имя может быть отдельным символом, не являющимся буквой, или одной или несколькими буквами без каких-либо «небуквенных» символов.

  \item {\tt\bf TextToReplace} содержит текст, который будет заменять имя новой команды каждый раз, когда он будет обнаружен в исходном файле.

\stopitemize

Например: представим, что мы хотим написать команду, которая производит открытие делового письма. Очень простой вариант:

{\switchtobodyfont[small]
\starttyping
\define\LetterHeading{
  \rightaligned{Peter Smith}\par
  \rightaligned{Consultant}\par
  Maryborough, \date\par
  Dear Sir,\par
  }
\stoptyping
}

но было бы предпочтительнее иметь версию команды, которая записывала бы имя получателя в заголовке. Это потребует использования параметра, который сообщает имя получателя новой команде. Для этого потребуется переопределить команду следующим образом:

{\switchtobodyfont[small]
\starttyping
\define[1]\LetterHeading{
  \rightaligned{Peter Smith}\par
  \rightaligned{Consultant}\par
  Maryborough, \date\par
  Dear Mr #1,\par
  }
\stoptyping
}

Обратите внимание, что мы внесли два изменения в определение. Прежде всего, между ключевым словом \tex{define} и новым именем команды мы заключили 1 в квадратные скобки ([1]). Это сообщает \ConTeXt, что определяемая нами команда будет иметь один аргумент. Далее, в последней строке определения команды, мы написали \quotation{{\tt Dear Mr \#1,}}, используя зарезервированный символ \MyKey{\#}. Это указывает на то, что в том месте текста замены, где появляется \MyKey{\#1}, будет вставлено содержимое первого аргумента. Если бы у него было два параметра, \MyKey{\#1} относился бы к первому параметру, а \MyKey{\#2} -- ко второму. Чтобы вызвать команду (в исходном файле) после имени команды, аргументы должны быть заключены в фигурные скобки, каждый аргумент должен иметь свой собственный набор. Итак, команда, которую мы только что определили, должна вызываться в тексте нашего исходного файла следующим образом:

\type{\LetterHeading{Name of addressee}}

% {\ttx \color[maincolor]{\backslash LetterHeading\{{\em Addressee
% name}\} }}

Например: \cmd{LetterHeading\{Anthony Moore\}}.

Мы могли бы еще больше улучшить предыдущую функцию, потому что она предполагает, что письмо будет отправлено мужчине (там написано «Уважаемый господин»), поэтому, возможно, мы могли бы включить еще один параметр, чтобы различать мужчин и женщин-адресатов. Например:

{\switchtobodyfont[small]
\starttyping
\define[2]\LetterHeading{
  \rightaligned{Peter Smith}\par
  \rightaligned{Consultant}\par
  Maryborough, \date\par
  #1\ #2,\par
  }
\stoptyping
}

чтобы функция вызывалась, например, с

{\tfx\type{\LetterHeading{Dear Ms}{Eloise Merriweather}}}

хотя это не очень элегантно (с точки зрения программирования). Было бы предпочтительно, чтобы для первого аргумента были определены символические значения (мужчина/женщина; 0/1; м/ж), чтобы сам макрос выбирал соответствующий текст в соответствии с этим значением. Но объяснение того, как этого добиться, требует от нас более глубокого понимания, чем, я думаю, начинающий читатель может понять на данном этапе.

\stopsubsection

\startsubsection
  [
    reference=sec:startstop,
    title=Создание новой среды,
  ]

\PlaceMacro{definestartstop}

Для создания новой среды \ConTeXt\ предоставляет команду \tex{definestartstop}, синтаксис которой следующий:

\type{\definestartstop[Name][Options]}

% {\ttx \color[maincolor]{\backslash definestartstop[{\em Name}][{\em
% Options}]}}

\startSmallPrint

В {\em официальном} определении \tex{definestartstop} (см. \in{section}[sec:qrc-setup-en]) есть дополнительный аргумент, который я не приводил выше, потому что он не является обязательным, и я не смог выяснить, для чего \Doubt он нужен. Ни вводная «Экскурсия» \ConTeXt, ни неполное справочное руководство не объясняют этого. Я предполагал, что этот аргумент (который должен быть введен между именем и конфигурацией) может быть именем некоторой существующей среды, которая будет служить исходной моделью для новой среды, но мои тесты показывают, что это предположение было неверным. Я просмотрел список рассылки \ConTeXt\ и не увидел никакого использования этого возможного аргумента.

\stopSmallPrint

где

\startitemize

  \item {\bf Name} это имя, которое будет иметь новая среда.

  \item {\bf Configuration} позволяет нам настраивать поведение новой среды. У нас есть следующие значения, с которыми мы можем его настроить:

  \startitemize

    \item {\tt before} -- Команды, которые необходимо выполнить перед входом в среду.

    \item {\tt after} -- Команды, которые необходимо запустить после выхода из среды.

    \item {\tt style} -- Стиль, который должен иметь текст нового окружения.

    \item {\tt setups} -- Набор команд, созданных с помощью
      \PlaceMacro{startsetups}\tex{startsetups ... \stopsetups}. Эта команда и её использование не объясняются во введении.

    \item {\tt color, inbetween, left, right} --  недокументированные варианты, которые мне не удалось заставить \Doubt работать. Мы можем предположить, что некоторые делают, из-за их имени, например {\tt цвета}, но из большего количества тестов, которые я провел, указывая какое-то значение для этой опции, я не увидел никаких изменений в среде.

  \stopitemize

\stopitemize

Пример определения среды может быть следующим:

{\switchtobodyfont[small]
\starttyping
\definestartstop
  [TextWithBar]
  [before=\startmarginrule\noindentation,
    after=\stopmarginrule,
    style=\ss\sl
  ]

\starttext

The first two fundamental laws of human stupidity state unambiguously
that:

\startTextWithBar

  \startitemize[n,broad]

    \item Always and inevitably we underestimate the number of stupid
    individuals in the world.

    \item The probability that a given person is stupid is independent
    of any other characteristic of the same person.

  \stopitemize

\stopTextWithBar

\stoptext
\stoptyping
}

Результат будет:

\definestartstop
  [TextWithBar]
  [before=\startmarginrule\noindentation,
    after=\stopmarginrule,
    style=\sl,
  ]

\startframedtext[frame=off]

  \color[red]{The first two fundamental laws of human stupidity state
  unambiguously that:

\startTextWithBar

\startitemize[n,broad]

  \item Always and inevitably we underestimate the number of stupid
  individuals in the world.

  \item The probability that a given person is stupid is independent of
  any other characteristic of the same person.

\stopitemize

\stopTextWithBar}
\stopframedtext

Если мы хотим, чтобы наша новая среда была группой (\in{section}[sec:groups]), чтобы любое изменение нормального функционирования \ConTeXt, происходящее в ней, исчезало при выходе из среды, мы должны включить команду \PlaceMacro{bgroup}\tex{bgroup} в параметр \MyKey{before}, и команду \PlaceMacro{egroup}\tex{egroup} в опции \MyKey{after}.

\stopsubsection

\stopsection

\startsection
  [title=Другие базовые концепции]

Помимо команд, существуют и другие понятия, которые имеют фундаментальное значение для понимания логики работы \ConTeXt. Некоторые из них из-за своей сложности не подходят для введения и поэтому не будут рассматриваться в этом документе; но есть два понятия, которые следует рассмотреть сейчас: группы и размеры.

\startsubsection
  [reference=sec:groups, title=Группы]

Группа -- это четко определенный фрагмент исходного файла, который \ConTeXt\ использует как {\em рабочую единицу} (что это означает, поясняется вкратце). У каждой группы есть начало и конец, которые необходимо четко указать. Группа начинается:

\startitemize[packed]

  \item Зарезервированным символом \MyKey{\{} or или командой \PlaceMacro{bgroup}\tex{bgroup}.

  \item Командой \PlaceMacro{begingroup}\tex{begingroup}

  \item Командой \PlaceMacro{start}\tex{start}

  \item При открытии определенной среды (команда \tex{startSomething}).

  \item Началом математического окружения (с зарезервированного символа «\$»)
\stopitemize

и закрывается

\startitemize[packed]

  \item Зарезервированным символом \MyKey{\}} or или командой
    \PlaceMacro{egroup}\tex{egroup}.

  \item Командой \PlaceMacro{endgroup}\tex{endgroup}

  \item Командой \PlaceMacro{stop}\tex{stop}

  \item При закрытии среды (команда \tex{stopSomething}).

  \item При выходе из математической среды (с зарезервированным символом «\$»).

\stopitemize

Некоторые команды также автоматически создают группу, например, \tex{hbox}, \tex{vbox} и, в общем, команды, связанные с созданием боксов \footnote{Понятие {\em box} также является центральным в \ConTeXt, но его объяснение не включено в это введение.}. За пределами этих последних случаев (группы, автоматически создаваемые определенными командами), способ закрытия группы должен соответствовать способу её открытия. Это означает, что группа, которая начинается с \MyKey{\{}, должна закрываться с помощью \MyKey{\}}, а группа, начинающаяся с \tex{begingroup}, должна быть закрыта с помощью \tex{endgroup}. У этого правила есть только одно исключение: группа, начатая с \MyKey{\{}, может быть закрыта с помощью \tex{egroup}, а группа, начатая с \tex{bgroup}, может быть закрыта с помощью \MyKey{\}}; в действительности это означает, что \MyKey{\{} и \tex{bgroup} полностью синонимичны и взаимозаменяемы, как и для \MyKey{\}} и \tex{egroup}.

\startSmallPrint

Команды \PlaceMacro{bgroup}\tex{bgroup} и \PlaceMacro{egroup}\tex{egroup} были разработаны, чтобы иметь возможность определять команды для открытия группы и других для закрытия группы. Следовательно, по причинам, внутренним для синтаксиса \TeX, эти группы нельзя было открывать и закрывать с помощью фигурных скобок, поскольку это привело бы к появлению несбалансированных фигурных скобок в исходном файле, и это всегда приводило бы к ошибке при компиляции.

Команды \PlaceMacro{begingroup}\tex{begingroup} и \PlaceMacro{endgroup}\tex{endgroup}, напротив, невзаимозаменяемы с фигурными скобками или командами \tex{bgroup  ... \egroup},поскольку группа, начинающаяся с \tex{begingroup} должна быть закрыта с помощью \tex{endgroup}. Эти последние команды были разработаны для более глубокой проверки ошибок. В общем, обычным пользователям их не нужно использовать.

\stopSmallPrint

У нас могут быть вложенные группы (группа внутри другой группы), и в этом случае порядок, в котором группы закрываются, должен соответствовать порядку, в котором они были открыты: любая подгруппа должна быть закрыта внутри группы, в которой она началась. Также могут быть пустые группы, созданные с помощью  \MyKey{\{\}}. Пустая группа, в принципе, не влияет на окончательный документ, но может быть полезна, например, для обозначения конца имени команды.

Основным эффектом групп является инкапсуляция их содержания: как правило, определения, форматы и присвоения значений, которые делаются внутри группы, «забываются», когда мы покидаем группу. Таким образом, если мы хотим, чтобы \ConTeXt\ временно изменил свой нормальный способ функционирования, наиболее эффективным способом является создание группы и изменение её функционирования внутри неё. Таким образом, когда мы выходим из группы, все предыдущие значения и форматы будут восстановлены. Мы уже видели несколько примеров этого при упоминании таких команд, как \tex{it}, \tex{bf}, \tex{sc} и т.д. Но это происходит не только с командами форматирования: группа каким-то образом изолирует своё содержимое, так что любое изменение в любом из многих внутренних переменных, которыми \ConTeXt\ постоянно управляет, будут оставаться эффективными только до тех пор, пока мы находимся в группе, в которой произошло это изменение. Точно так же команда, определенная в группе, не будет известна за её пределами.

Итак, если обработать следующий пример

\starttyping
\define\A{B}
\A
{
  \define\A{C}
  \A
}
\A
\stoptyping

мы увидим, что при первом запуске команды \tex{A} результат соответствует результату её первоначального определения (\quote{B}). Затем мы создали группу и переопределили в ней команду \tex{A}. Если мы запустим её сейчас в группе, команда выдаст нам новое определение (в нашем примере \quote{C}), но когда мы выйдем из группы, в которой была переопределена команда \tex{A}, если мы запустим её снова, она напечатает \quote{B} ещё раз. Определение, данное в группе, «забывается», как только мы из неё вышли.

Другое возможное использование групп касается тех команд или инструкций, которые предназначены для применения исключительно к символу, который написан после них. В этом случае, если мы хотим, чтобы команда применялась к более чем одному символу, мы должны заключить символы, к которым мы хотим применить команду или инструкцию, в группу. Так, например, зарезервированный символ \MyKey{\letterhat}, который, как мы уже знаем, преобразует следующий символ в надстрочный индекс при использовании внутри математической среды; поэтому, если мы напишем, например, \MyKey{\$4^2x\$}, мы получим \quotation{$4^2x$}. Но если мы напишем \MyKey{\$4^\{2x\}\$}, мы получим \quotation{$4^{2x}$}.

Наконец: третье использование группировки -- сказать \ConTeXt, что то, что заключено в группу, должно рассматриваться как одно целое. Это причина, по которой ранее (\in{section}[sec:syntax]) было сказано, что в определенных случаях лучше заключить содержимое некоторой опции команды в фигурные скобки.

\stopsubsection

\startsubsection
  [reference=sec:dimensions, title=Размеры]

Хотя можно было бы идеально использовать \ConTeXt, не беспокоясь о размерах, тем не менее мы не сможем использовать все возможности конфигурации, не уделив им некоторого внимания. Потому что в значительной степени типографское совершенство, достигнутое \TeX\ и его производными, заключается в большом внимании, которое система уделяет внутренним размерам. Символы имеют размеры; пространство между словами, или между строками, или между абзацами имеет размеры; линии имеют размеры; поля, верхние и нижние колонтитулы. Почти для каждого элемента на странице, о котором мы только можем подумать, будет какое-то измерение.

В \ConTeXt\ размеры указываются десятичным числом, за которым следует единица измерения. Единицы, которые можно использовать, указаны в \in{table}[tbl:measurements].

\placetable
  [here]
  [tbl:measurements]
  {Единицы измерений в  \ConTeXt}
{\starttabulate[|l|c|l|]
  \NC {\bf Наименование} \NC {\bf Имя в \ConTeXt}\NC {\bf Эквивалент}\NR
\NC Inch\NC in\NC 1 in $=$ 2.54 cm\NR
\NC Centimetre\NC cm\NC 2.54 cm $=$ 1 inch\NR
\NC Millimetre\NC mm\NC 10 mm $=$ 1 cm\NR
\NC Point\NC pt\NC 72.27 pt $=$ 1 inch\NR
\NC Big point\NC bp\NC 72 bp $=$ 1 inch\NR
\NC Scaled point\NC sp\NC 65536 sp $=$ 1 point\NR
\NC Pica\NC pc\NC 1 pc $=$ 12 points\NR
\NC Didot\NC dd\NC 1157 dd $=$ 1238 points\NR
\NC Cicero\NC cc\NC 1 cc $=$ 12 didots\NR
\NC\NC em\NR
\NC\NC ex\NR
\stoptabulate
}

Первые три единицы в \in{table}[tbl:measurements] -- стандартные меры длины; первый используется в некоторых частях англоязычного мира, а другие -- вне его или в некоторых его частях. Остальные единицы взяты из мира типографики. Последние два, для которых я не поставил эквивалента, являются относительными единицами измерения, основанными на текущем шрифте. 1 \quotation{em} равен ширине \quotation{M}, а  \quotation{ex} равен высоте \quotation{x}. Использование мер, связанных с размером шрифта, позволяет создавать макросы, которые выглядят одинаково хорошо независимо от источника, используемого в любой момент. Вот почему в целом рекомендуется.

За очень немногими исключениями мы можем использовать любую единицу измерения, которую мы предпочитаем, поскольку \ConTeXt\ преобразует её внутренне. Но всякий раз, когда указывается размер, необходимо указывать единицу измерения, и даже если мы хотим указать размер «0», мы должны сказать «0pt» или «0 см». Между номером и названием единицы мы можем или не можем оставлять пробел. Если единица имеет десятичную часть, мы можем использовать десятичный разделитель, либо (.), Либо запятую (,).

Измерения обычно используются как опция для какой-либо команды. Но мы также можем напрямую присвоить значение некоторой внутренней мере \ConTeXt, если мы знаем её имя. Например, отступ первой строки обычного абзаца внутренне контролируется \ConTeXt\ с помощью переменной \PlaceMacro{parindent}\tex{parindent}. Явно присвоив значение этой переменной, мы поменяем измерение, которое \ConTeXt\ использует с этого момента. И поэтому, например, если мы хотим устранить отступ в первой строке, нам нужно только написать в нашем исходном файле:

\type{\parindent=0pt}

Мы также могли написать \tex{parindent 0pt} (без знака равенства) или \tex{parindent0pt} без пробела между именем меры и её значением.

Однако присвоение значения непосредственно внутренней мере считается «неэлегантным». Как правило, рекомендуется использовать команды, управляющие этой переменной, и делать это в преамбуле исходного файла. Обратное приводит к исходным файлам, которые очень трудно отлаживать, потому что не все команды конфигурации находятся в одном и том же месте, и действительно трудно добиться определенной согласованности типографских характеристик.

Некоторые измерения, используемые \ConTeXt, являются «эластичными», то есть, в зависимости от контекста, они могут принимать ту или иную меру. Этим мерам присваивается следующий синтаксис:


\type{\MeasureName plus MaxIncrement minus MaxDecrease}

% {\tt\backslash {\em MeasureName} plus {\em MaxIncrement} minus
%   {\em MinDecrease}}

Например

\type{\parskip 3pt plus 2pt minus 1pt}

С помощью этой инструкции мы говорим \ConTeXt\ назначить \PlaceMacro{parskip}\tex{parskip} (указывающее вертикальное расстояние между абзацами) обычное измерение в 3 пункта, но если этого требует состав страницы, измерение может составлять до 5 пунктов (3 плюс 2 ) или всего 2 балла (3 минус 1). В этих случаях \ConTeXt\ останется выбирать расстояние для каждой страницы от минимум 2 до максимум 5 точек.

\stopsubsection

\stopsection

\startsection
  [title=Метод самообучения для \ConTeXt]

  % Section added at the last moment, when I realised that I myself
  % had become so imbued with the spirit of ConTeXt that I was able to
  % guess the existence of certain commands.

Огромное количество команд и опций \ConTeXt\ действительно ошеломляет и может дать нам ощущение, что мы никогда не научимся хорошо с ним работать. Это впечатление было бы ошибкой, потому что одним из преимуществ \ConTeXt\ является единообразный способ обработки всех своих структур: хорошее изучение нескольких структур и более или менее знание того, для чего нужны остальные, когда нам нужна дополнительная утилита, научиться им пользоваться будет относительно легко. Поэтому я считаю это введение своего рода {\em тренировкой}, которая подготовит нас к проведению собственных исследований.

Чтобы создать документ с помощью \ConTeXt, вероятно, необходимо знать только следующие пять вещей (мы могли бы назвать их пятеркой лучших по \ConTeXt):

\startitemize[n]

  \item Знать, как создать исходный файл или любой проект; это объясняется в \in{Chapter}[cap:sourcefile] этого введения.

  \item Установить основной шрифт для документа и узнать основные команды для изменения шрифта и цвета (\in{Chapter}[sec:fontscol]).

  \item Знать основные команды для структурирования содержимого нашего документа, такие как главы, разделы, подразделы и т.д. Все это объясняется в  \in{Chapter}[cap:structure].

  \item Возможно, вы знаете, как работать со средой детализации, подробно описанной в \in{section}[sec:itemize].

  \item ... и еще немного.

\stopitemize

В остальном всё, что нам нужно знать, это то, что это возможно. Конечно, никто не будет использовать утилиту, если не знает, что она существует. Многие из них объясняются в этом введении; но, прежде всего, мы можем неоднократно наблюдать, как \ConTeXt\ всегда действует, когда сталкивается с определенным типом конструкции:

\startitemize

  \item Сначала будет команда, позволяющая это сделать.

  \item Во-вторых, почти всегда есть команда, которая позволяет нам настроить и заранее определить, как будет выполняться задача; команда, имя которой начинается с \tex{setup}  и обычно совпадает с основной командой.

  \item Наконец, часто можно создать новую команду для выполнения аналогичных задач, но с другой конфигурацией.

\stopitemize

Чтобы узнать, существуют ли эти команды или нет, посмотрите официальный список команд (см. \in{section}[sec:qrc-setup-en]),  который также проинформирует нас о параметрах конфигурации, поддерживаемых этими командами. И хотя на первый взгляд названия этих опций могут показаться загадочными, мы скоро увидим, что есть опции, которые повторяются во многих командах и работают одинаково или очень похоже во всех из них. Если у нас есть сомнения относительно того, что делает опция или как она работает, этого будет достаточно, чтобы сгенерировать документ и протестировать его. Мы также можем ознакомиться с обширной документацией по \ConTeXt. Как это принято в мире бесплатного программного обеспечения, \suite- включает исходные коды почти всей своей документации в дистрибутив. Утилита, такая как \MyKey{grep} (для систем GNU Linux), может помочь нам найти, используется ли команда или параметр, в отношении которых мы сомневаемся, в каком-либо из этих исходных файлов, чтобы у нас был под рукой пример.

Вот как было задумано изучение \ConTeXt: во введении подробно объясняются пять (фактически четыре) аспекта, которые я выделил, и многое другое: по мере чтения в нашем сознании сформируется четкая картина последовательности: {\em команда для выполнения задачи} -- {\em команда, которая настраивает предыдущую} -- {\em команда, которая позволяет нам создать аналогичную команду}. Мы также изучим некоторые из основных структур \ConTeXt\ и узнаем, для чего они нужны.

\stopsection

\stopchapter

\stopcomponent

%%% Local Variables:
%%% mode: ConTeXt
%%% mode: auto-fill
%%% TeX-master: "../introCTX.mkiv"
%%% coding: utf-8-unix
%%% End:
%%% vim:set filetype=context tw=72 : %%%
